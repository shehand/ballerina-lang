{
  "position": {
    "line": 11,
    "character": 10
  },
  "source": "resource/source/completionBeforeUnderscore1.bal",
  "items": [
    {
      "label": "DEFAULT",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": " Default value is the format specified by the CSVChannel. Precedence will be given to the field separator and record separator."
        }
      },
      "sortText": "130",
      "insertText": "DEFAULT",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "CSV",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Field separator will be \",\" and the record separator will be a new line."
        }
      },
      "sortText": "130",
      "insertText": "CSV",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "TDF",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Field separator will be a tab and the record separator will be a new line."
        }
      },
      "sortText": "130",
      "insertText": "TDF",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "COMMA",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Comma (,) will be used as the field separator."
        }
      },
      "sortText": "130",
      "insertText": "COMMA",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "TAB",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Tab (/t) will be use as the field separator."
        }
      },
      "sortText": "130",
      "insertText": "TAB",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "COLON",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Colon (:) will be use as the field separator."
        }
      },
      "sortText": "130",
      "insertText": "COLON",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "CONNECTION_TIMED_OUT",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "This will be used to construct a ConnectionTimedOutError."
        }
      },
      "sortText": "130",
      "insertText": "CONNECTION_TIMED_OUT",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "GENERIC_ERROR",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "This will be used to construct an IO GenericError."
        }
      },
      "sortText": "130",
      "insertText": "GENERIC_ERROR",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ACCESS_DENIED_ERROR",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "This will be used to construct a AccessDeniedError."
        }
      },
      "sortText": "130",
      "insertText": "ACCESS_DENIED_ERROR",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "FILE_NOT_FOUND_ERROR",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "This will be used to construct a FileNotFoundError."
        }
      },
      "sortText": "130",
      "insertText": "FILE_NOT_FOUND_ERROR",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "END_OF_FILE_ERROR",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "This will be used to construct an EofError."
        }
      },
      "sortText": "130",
      "insertText": "END_OF_FILE_ERROR",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "CSV_RECORD_SEPARATOR",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Represents the record separator of the CSV file."
        }
      },
      "sortText": "130",
      "insertText": "CSV_RECORD_SEPARATOR",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "FS_COLON",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Represents the colon separator, which should be used to identify colon-separated files."
        }
      },
      "sortText": "130",
      "insertText": "FS_COLON",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "MINIMUM_HEADER_COUNT",
      "kind": "Variable",
      "detail": "int",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Represents the minimum number of headers, which will be included in the CSV."
        }
      },
      "sortText": "130",
      "insertText": "MINIMUM_HEADER_COUNT",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "BIG_ENDIAN",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Specifies the bytes to be in the order of most significant byte first."
        }
      },
      "sortText": "130",
      "insertText": "BIG_ENDIAN",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "LITTLE_ENDIAN",
      "kind": "Variable",
      "detail": "string",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "Specifies the byte order to be the least significant byte first."
        }
      },
      "sortText": "130",
      "insertText": "LITTLE_ENDIAN",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "Format",
      "detail": "Union",
      "documentation": {
        "left": "The format, which will be used to represent the CSV.\n\nDEFAULT - The default value is the format specified by the CSVChannel. Precedence will be given to the field\n          separator and record separator.\n\nCSV - Field separator will be \",\" and the record separator will be a new line.\n\nTDF - Field separator will be a tab and record separator will be a new line."
      },
      "sortText": "110",
      "insertText": "Format",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "Separator",
      "kind": "Enum",
      "detail": "Union",
      "documentation": {
        "left": "Field separators, which are supported by the `DelimitedTextRecordChannel`.\n\nCOMMA - Delimited text records will be separated using a comma.\n\nTAB - Delimited text records will be separated using a tab.\n\nCOLON - Delimited text records will be separated using a colon(:)."
      },
      "sortText": "160",
      "insertText": "Separator",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "Detail",
      "kind": "Struct",
      "detail": "Record",
      "documentation": {
        "left": "Record type to hold the details of an error.\n"
      },
      "sortText": "180",
      "insertText": "Detail",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ConnectionTimedOutError",
      "kind": "Event",
      "detail": "Error",
      "documentation": {
        "left": "This will return when connection timed out happen when try to connect to a remote host."
      },
      "sortText": "200",
      "insertText": "ConnectionTimedOutError",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "GenericError",
      "kind": "Event",
      "detail": "Error",
      "documentation": {
        "left": "Represents generic IO error. The detail record contains the information related to the error."
      },
      "sortText": "200",
      "insertText": "GenericError",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "AccessDeniedError",
      "kind": "Event",
      "detail": "Error",
      "documentation": {
        "left": "This will get returned due to file permission issues."
      },
      "sortText": "200",
      "insertText": "AccessDeniedError",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "FileNotFoundError",
      "kind": "Event",
      "detail": "Error",
      "documentation": {
        "left": "This will get returned if the file is not available in the given file path."
      },
      "sortText": "200",
      "insertText": "FileNotFoundError",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "EofError",
      "kind": "Event",
      "detail": "Error",
      "documentation": {
        "left": "This will get returned if read operations are performed on a channel after it closed."
      },
      "sortText": "200",
      "insertText": "EofError",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "Error",
      "kind": "Event",
      "detail": "Union",
      "documentation": {
        "left": "Represents IO module related errors."
      },
      "sortText": "200",
      "insertText": "Error",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ReadableByteChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "ReadableByteChannel represents an input resource (i.e file). which could be used to source bytes."
      },
      "sortText": "190",
      "insertText": "ReadableByteChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ReadableCharacterChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel, which could be used to read characters through a given ReadableByteChannel."
      },
      "sortText": "190",
      "insertText": "ReadableCharacterChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ReadableCSVChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a ReadableCSVChannel which could be used to read records from CSV file."
      },
      "sortText": "190",
      "insertText": "ReadableCSVChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ReadableDataChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a data channel for reading data."
      },
      "sortText": "190",
      "insertText": "ReadableDataChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ReadableTextRecordChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which will allow to read"
      },
      "sortText": "190",
      "insertText": "ReadableTextRecordChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "StringReader",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a reader which will wrap string content as a channel."
      },
      "sortText": "190",
      "insertText": "StringReader",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "WritableByteChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "WritableByteChannel represents an output resource (i.e file). which could be used to sink bytes."
      },
      "sortText": "190",
      "insertText": "WritableByteChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "WritableCharacterChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel which could be used to write characters through a given WritableCharacterChannel."
      },
      "sortText": "190",
      "insertText": "WritableCharacterChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "WritableCSVChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a WritableCSVChannel, which could be used to write records from the CSV file."
      },
      "sortText": "190",
      "insertText": "WritableCSVChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "ByteOrder",
      "kind": "TypeParameter",
      "detail": "Finite",
      "documentation": {
        "left": "Represents network byte order.\n\nBIG_ENDIAN - specifies the bytes to be in the order of most significant byte first\n\nLITTLE_ENDIAN - specifies the byte order to be the least significant byte first"
      },
      "sortText": "170",
      "insertText": "ByteOrder",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "WritableDataChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a WritableDataChannel for writing data."
      },
      "sortText": "190",
      "insertText": "WritableDataChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "WritableTextRecordChannel",
      "kind": "Interface",
      "detail": "Object",
      "documentation": {
        "left": "Represents a channel, which will allow to write records through a given WritableCharacterChannel."
      },
      "sortText": "190",
      "insertText": "WritableTextRecordChannel",
      "insertTextFormat": "Snippet"
    },
    {
      "label": "openReadableFile(string path)((io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a `ReadableByteChannel` from a given file path.\n```ballerina\n# io:ReadableByteChannel readableFieldResult = check io:openReadableFile(\"./files/sample.txt\");\n#```\n  \n**Params**  \n- `string` path: Relative/absolute path string to locate the file  \n  \n**Returns** `(io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError)`   \n- The `ByteChannel` representation of the file resource or else an `io:Error` if any error occurred  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "openReadableFile(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openWritableFile(string path, boolean append)((io:WritableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a `WritableByteChannel` from a given file path.\n```ballerina\n# io:WritableByteChannel writableFileResult = check io:openWritableFile(\"./files/sampleResponse.txt\");\n# ```\n  \n**Params**  \n- `string` path: Relative/absolute path string to locate the file  \n- `boolean` append: Whether to append to the end of file(Defaultable)  \n  \n**Returns** `(io:WritableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError)`   \n- The `ByteChannel` representation of the file resource or else an `io:Error` if any error occurred  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "openWritableFile(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "createReadableChannel(byte[] content)((io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nCreates an in-memory channel, which will be a reference stream of bytes.\n```ballerina\n# var byteChannel = io:createReadableChannel(content);\n# ```\n  \n**Params**  \n- `byte[]` content: Content, which should be exposed as a channel  \n  \n**Returns** `(io:ReadableByteChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError)`   \n- The `ByteChannel` representation to read the memory content or else an `io:Error` if any error occurred  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "createReadableChannel(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openReadableCsvFile(string path, (,|\t|:|string) fieldSeparator, string charset, int skipHeaders)((io:ReadableCSVChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a readable CSV channel from a given file path.\n```ballerina\n# io:ReadableCSVChannel rCsvChannel = check io:openReadableCsvFile(srcFileName);\n# ```\n  \n**Params**  \n- `string` path: File path, which describes the location of the CSV  \n- `(,|\t|:|string)` fieldSeparator: CSV record separator (i.e., comma or tab)(Defaultable)  \n- `string` charset: Representation of the encoding characters in the file (Defaultable)  \n- `int` skipHeaders: Number of headers, which should be skipped(Defaultable)  \n  \n**Returns** `(io:ReadableCSVChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError)`   \n- The `ReadableCSVChannel`, which could be used to iterate through the CSV records or else an `io:Error` if any error occurred.  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "openReadableCsvFile(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "openWritableCsvFile(string path, (,|\t|:|string) fieldSeparator, string charset, int skipHeaders)((io:WritableCSVChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError))",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves a writable CSV channel from a given file path.\n```ballerina\n# io:WritableCSVChannel wCsvChannel = check io:openWritableCsvFile(srcFileName);\n# ```\n  \n**Params**  \n- `string` path: File path, which describes the location of the CSV  \n- `(,|\t|:|string)` fieldSeparator: CSV record separator (i.e., comma or tab)(Defaultable)  \n- `string` charset: Representation of the encoding characters in the file (Defaultable)  \n- `int` skipHeaders: Number of headers, which should be skipped(Defaultable)  \n  \n**Returns** `(io:WritableCSVChannel|io:GenericError|io:ConnectionTimedOutError|io:AccessDeniedError|io:FileNotFoundError|io:EofError)`   \n- The `WritableCSVChannel`, which could be used to write the CSV records or else an `io:Error` if any error occurred  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "openWritableCsvFile(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "print((any|error)... values)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nPrints `any` or `error` value(s) to the STDOUT.\n```ballerina\n#io:print(\"Start processing the CSV file from \", srcFileName);\n#```\n  \n**Params**  \n- `(any|error)[]` values: The value(s) to be printed."
        }
      },
      "sortText": "120",
      "insertText": "print(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "println((any|error)... values)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nPrints `any` or `error` value(s) to the STDOUT followed by a new line.\n```ballerina\n#io:println(\"Start processing the CSV file from \", srcFileName);\n#```\n   \n**Params**  \n- `(any|error)[]` values: The value(s) to be printed."
        }
      },
      "sortText": "120",
      "insertText": "println(${1});",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "sprintf(string format, (any|error)... args)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nReturns a formatted string using the specified format string and arguments. Following format specifiers are allowed.\n\nb - boolean\n\nB - boolean (ALL_CAPS)\n\nd - int\n\nf - float\n\nx - hex\n\nX - HEX (ALL_CAPS)\n\ns - string (This specifier is applicable for any of the supported types in Ballerina.\n            These values will be converted to their string representation.)\n\n```ballerina\n# string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\", name, marks, subjects[0], average);\n# ```\n  \n**Params**  \n- `string` format: A format string  \n- `(any|error)[]` args: Arguments referred by the format specifiers in the format string  \n  \n**Returns** `string`   \n- The formatted string  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "sprintf(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    },
    {
      "label": "readln(any a)(string)",
      "kind": "Function",
      "detail": "Function",
      "documentation": {
        "right": {
          "kind": "markdown",
          "value": "**Package:** _ballerina/io_  \n  \nRetrieves the input read from the STDIN.\n```ballerina\n# string choice = io:readln(\"Enter choice 1 - 5: \");\n# ```\n  \n**Params**  \n- `any` a: Any value to be printed  \n  \n**Returns** `string`   \n- Input read from the STDIN  \n  \n"
        }
      },
      "sortText": "120",
      "insertText": "readln(${1})",
      "insertTextFormat": "Snippet",
      "command": {
        "title": "editor.action.triggerParameterHints",
        "command": "editor.action.triggerParameterHints"
      }
    }
  ]
}
